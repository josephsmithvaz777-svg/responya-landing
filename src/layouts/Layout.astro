---
interface Props {
	title: string;
	description?: string;
}

const {
	title,
	description = "Desarrollamos soluciones de software a medida potenciadas por Inteligencia Artificial",
} = Astro.props;
---

<!doctype html>
<html lang="es" class="dark">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content={description} />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<title>{title}</title>

		<!-- Google Fonts -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap"
			rel="stylesheet"
		/>
		<link
			href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap"
			rel="stylesheet"
		/>
	</head>
	<body
		class="bg-[#030014] text-white overflow-x-hidden w-full min-h-screen flex flex-col selection:bg-cyan-500/30"
	>
		<!-- Background Effects - Fixed para que siempre estén visibles -->
		<div class="fixed inset-0 z-0 pointer-events-none">
			<div class="stars absolute inset-0"></div>
			<div
				class="absolute top-0 -left-20 w-96 h-96 bg-purple-600/20 rounded-full mix-blend-screen filter blur-[100px] animate-blob"
			>
			</div>
			<div
				class="absolute top-0 -right-20 w-96 h-96 bg-cyan-600/20 rounded-full mix-blend-screen filter blur-[100px] animate-blob animation-delay-2000"
			>
			</div>
			<div
				class="absolute -bottom-40 left-20 w-96 h-96 bg-pink-600/20 rounded-full mix-blend-screen filter blur-[100px] animate-blob animation-delay-4000"
			>
			</div>
		</div>

		<slot />

		<script is:inline>
			// Esperar a que el DOM esté completamente cargado
			document.addEventListener("DOMContentLoaded", function () {
				// Smooth Scroll for all anchor links with custom easing
				document
					.querySelectorAll('a[href^="#"]')
					.forEach(function (anchor) {
						anchor.addEventListener("click", function (e) {
							const href = this.getAttribute("href");

							// Si es solo "#", ir al top
							if (href === "#") {
								e.preventDefault();
								smoothScrollTo(0, 1200);
								return;
							}

							// Para otros enlaces con hash
							const targetId = href.substring(1);
							const targetElement =
								document.getElementById(targetId);

							if (targetElement) {
								e.preventDefault();

								// Calcular la posición con offset para el header fijo
								const headerOffset = 80; // Altura del header
								const elementPosition =
									targetElement.getBoundingClientRect().top;
								const offsetPosition =
									elementPosition +
									window.pageYOffset -
									headerOffset;

								// Usar scroll suave personalizado
								smoothScrollTo(offsetPosition, 1200);

								// Actualizar la URL sin hacer scroll
								history.pushState(null, null, href);
							}
						});
					});

				// Función de scroll suave personalizada con easing
				function smoothScrollTo(targetPosition, duration) {
					const startPosition = window.pageYOffset;
					const distance = targetPosition - startPosition;
					let startTime = null;

					// Función de easing para un movimiento más suave (easeInOutCubic)
					function easeInOutCubic(t) {
						return t < 0.5
							? 4 * t * t * t
							: 1 - Math.pow(-2 * t + 2, 3) / 2;
					}

					function animation(currentTime) {
						if (startTime === null) startTime = currentTime;
						const timeElapsed = currentTime - startTime;
						const progress = Math.min(timeElapsed / duration, 1);
						const ease = easeInOutCubic(progress);

						window.scrollTo(0, startPosition + distance * ease);

						if (timeElapsed < duration) {
							requestAnimationFrame(animation);
						}
					}

					requestAnimationFrame(animation);
				}

				// Parallax Effect for Background Elements
				document.addEventListener("mousemove", function (e) {
					const x = e.clientX / window.innerWidth;
					const y = e.clientY / window.innerHeight;
					const blobs = document.querySelectorAll(".animate-blob");
					blobs.forEach(function (blob, index) {
						const speed = (index + 1) * 20;
						blob.style.transform =
							"translate(" +
							x * speed +
							"px, " +
							y * speed +
							"px)";
					});
					const grid = document.querySelector(".bg-tech-grid");
					if (grid) {
						grid.style.backgroundPosition =
							x * 10 + "px " + y * 10 + "px";
					}
				});

				// Intersection Observer for scroll animations
				const observerOptions = {
					threshold: 0.1,
					rootMargin: "0px 0px -50px 0px",
				};

				const observer = new IntersectionObserver(function (entries) {
					entries.forEach(function (entry) {
						if (entry.isIntersecting) {
							entry.target.classList.add("visible");
						}
					});
				}, observerOptions);

				// Observar todos los elementos con la clase animate-on-scroll
				const elements =
					document.querySelectorAll(".animate-on-scroll");
				console.log(
					"Observing " +
						elements.length +
						" elements with animate-on-scroll",
				);
				elements.forEach(function (el) {
					observer.observe(el);
				});
			});
		</script>
	</body>
</html>
